---
tile: "大溪地"
---

## InnoDB中如何使用临键锁解决幻读问题

*（说明：本文的所有讨论只针对InnoDB引擎下的Repeatable Read隔离级别）*

#### 什么是幻读问题

幻读问题指的是在并发事务中因为插入操作导致的读一致性被破坏的问题，举例来说：

* 有两个并发事务A、B
* A读取某个区间，此时这个区间中没有数据
* B在该区间中插入了某条记录
* A再次读取该区间，此时这个区间中已经有了数据
* 因为B事务的插入操作，A事务中前后两次读取同一个区间返回的结果不一致，这种现象就叫做幻读问题。

#### InnoDB中如何解决幻读问题

InnoDB中存在两种方式的读：

* 非锁定读：读取的是历史版本，好处是因为没有上锁，所以并发效率高；适用于常规的SELECT语句
* 锁定读：需要上锁，总是读取最新的版本；适用于INSERT、DELETE、UPDATE，以及SELECT … LOCK IN SHORE MODE和SELECT … LOCK FOR UPDATE

非锁定读通过多版本并发控制（MVCC）实现，读取的是历史版本，具体来说，只会读取在事务创建之前插入、修改的数据。因此在事务创建之后，其它事务的插入和修改对当前事务不可见。

也就是说，**对非锁定读来说，MVCC已经解决了幻读问题**。

**对于锁定读来说，则是使用临键锁来解决幻读问题**。

#### 什么是临键锁

InnoDB引擎支持行锁，行锁是基于索引的，分为如下三种：

* 记录锁：在某个索引项上加锁
* 间隙锁：对某个空白索引区间加锁
* 临键锁：对某个索引项以及该索引项前的空白区间加锁，因此效果上等于间隙锁+记录锁

举例来说，假设表a中有如下的index索引序列，[…, 1, 3, 5, 7, 9, …]，在索引项3上加临键锁，就是给(1, 3]这个区间加上了锁。

#### 临键锁如何解决幻读问题

准确的说，是间隙锁和临键锁一起解决幻读问题。

幻读的产生可能有如下几种情况（还是以上面的index索引序列举例）：

##### 等值查询没有命中

* 事务A做index=2的等值查询，返回为空
* 事务B插入了一条index=2的记录
* 事务A再次执行index=2的等值查询，返回新纪录，两次读取不一致

针对如上的情况，只需要在index=2的等值查询没有命中的时候，对区间(1, 3)加间隙锁即可解决。

##### 范围查询

* 事务A执行区间[3, 6]上的范围查询，返回index=3和index=5的记录
* 事务B插入index=6的记录
* 事务A再次执行区间[3, 6]上的范围查询，返回index=3、index=5和index=6的记录，两次读取不一致

针对如上情况，需要使用临键锁。

首先在索引列表中找到第一个满足范围的索引项，在本例中是index=3，在该索引项上加上临键锁；然后逐个往后遍历，对所有满足范围的索引项加上临键锁，所以index=5的索引项也被加上临键锁；直到找到第一个超出范围的索引项，index=7，在该索引项上也加上临键锁（为什么是临键锁，而不是间隙锁？存疑），加锁过程结束。

*（每一个索引序列最后都有一条supremum记录，表示不可能到达的极大值，使得加锁过程总是能够终止。）*

从效果上看，在区间[2, 6]上做了范围查询之后，实际上是对(1, 7]这个区间加上了锁，如此便可解决在区间[2, 6]上做范围查询的幻读问题。

*（如果本例中的索引序列是唯一索引，index=3刚好命中了[3, 6]的左闭区间值，这种情况会对index=3的索引项加上记录锁而不是临键锁，所以最终的加锁区间是[3, 7]）*

##### 非唯一索引等值查询

以上两种情况下的幻读问题都比较直观，而非以索引等值查询产生的幻读问题则更复杂一点，首先需要了解InnoDB中的非唯一索引的B+树结构。

B+树要求元素是唯一的，包括叶子节点上的元素和非叶子节点上的元素。对于非唯一索引B+树，非叶子节点中的元素如果只是记录索引值，就可能出现两个元素的索引值相同的情况，所以其实飞叶子节点上的每个元素除了索引值之外，还保存了主键值，在索引值相同的情况下，通过主键值来区分。

**如果如上的索引序列是非唯一索引，在执行等值查询（比如index=3）的时候，如果仅仅是对匹配的索引项加上记录锁，并不能阻塞其它事务在索引序列中插入新的拥有相同索引值的记录**，因为还可以在1和3之间、3和3之间、3和5之间插入index=3的记录。

考虑这样的情况：

* 事务A执行index=3的范围查询，得到一条记录
* 事务B插入了一条新的index=3的记录
* 事务A再次执行index=3的范围查询，得到两条记录，两次查询结果不一致

针对如上的情况，使用临键锁+间隙锁的加锁策略来解决幻读问题：首先对所有匹配的索引项加上临键锁，然后对于最后一个匹配的索引项，在其后的空闲区间加上间隙锁。

所以执行了index=3的等值查询之后，实际上是对区间(1, 5)加上了锁，这样就杜绝了插入index=3的记录的可能。

##### 非索引条件查询

因为行锁是基于索引的，所以在这种情况下没法针对查询条件涉及的列加行锁，也就是说插入的新记录，查询条件相关的列值不受控制，显而易见这种不受控制的插入会导致幻读。为了解决这种幻读，只能是对全表加锁。但是在实现上，加的还是临键锁。

既然是非索引条件查询，那么只能执行全表扫描。全表扫描是在聚簇索引上执行的，也就是说按照主键的顺序逐个扫描，每扫描到一条记录，就在该主键上加上临键锁。**所以一次全表扫描结束后，其实是在聚簇索引上对所有聚簇索引项（也就是主键）加上了临键锁，从效果上来看，相当于给全表加上了一个表锁**。